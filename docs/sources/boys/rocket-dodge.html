<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>Neon Strike: Alien Defense+</title>
  <style>
    :root{
      --bg1:#03070f;
      --bg2:#09142b;
      --grid:#0e1837;
      --fg:#e6f0ff;
      --accent:#00d4ff;
      --accent2:#00ffa6;
      --danger:#ff3d5a;
      --enemy:#8dfc2d;
      --ship:#9edaff;
      --power:#5df2ff;
      --shadow:rgba(0,255,255,.25);
      --boss:#ff6b00;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100svh;margin:0;overflow:hidden;background:radial-gradient(1200px 800px at 70% -10%,#0a1738 0%,transparent 60%),linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{width:100%;height:100%;display:block;touch-action:none}
    .hud{position:fixed;inset:env(safe-area-inset-top) 12px auto 12px;display:flex;align-items:center;gap:8px;justify-content:space-between;pointer-events:none}
    .leftHUD,.rightHUD{display:flex;gap:8px;align-items:center}
    .pill{pointer-events:auto;background:rgba(0,10,26,.45);backdrop-filter:blur(6px);border:1px solid rgba(0,255,255,.15);border-radius:14px;padding:6px 10px;font-weight:700;letter-spacing:.3px;box-shadow:0 0 0 1px rgba(255,255,255,.03) inset;white-space:nowrap}
    .bar{position:relative;width:140px;height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden}
    .bar>i{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,var(--accent),#2bffd0);box-shadow:0 0 12px rgba(0,255,255,.5) inset}
    .tiny{opacity:.9;font-weight:600}
    .btn{pointer-events:auto;cursor:pointer;user-select:none}
    .btn:active{transform:translateY(1px)}
    .hidden{display:none}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(2,6,15,.8),rgba(2,6,15,.65));backdrop-filter:blur(2px)}
    .card{max-width:min(760px,94vw);text-align:center;padding:22px 18px;border-radius:18px;background:linear-gradient(180deg,rgba(0,15,35,.7),rgba(0,10,25,.5));border:1px solid rgba(0,255,255,.2);box-shadow:0 20px 60px rgba(0,0,0,.45)}
    h1{margin:6px 0 6px;font-size:28px;letter-spacing:.8px;color:#c8e9ff;text-shadow:0 0 18px rgba(0,180,255,.35)}
    p{margin:6px 0;color:#b8d0ff}
    .cta{display:inline-block;margin-top:10px;padding:12px 18px;border-radius:14px;font-weight:800;letter-spacing:.6px;background:linear-gradient(90deg,var(--accent),#58ffd1);color:#002033;border:none;cursor:pointer;box-shadow:0 6px 26px rgba(0,220,255,.35)}
    .sub{font-size:12px;opacity:.85}
    .gridOverlay{position:fixed;inset:0;pointer-events:none;opacity:.14}
    .touchHints{position:fixed;left:0;right:0;bottom:max(10px,env(safe-area-inset-bottom));display:flex;justify-content:space-between;gap:10px;padding:0 10px;pointer-events:none}
    .hint{pointer-events:none;color:#9ecbff;font-size:12px;background:rgba(0,15,35,.4);border:1px solid rgba(0,255,255,.15);padding:6px 8px;border-radius:10px}
    .bossbar{position:fixed;left:50%;transform:translateX(-50%);top:calc(env(safe-area-inset-top) + 56px);width:min(620px,90vw);height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.3);display:none}
    .bossbar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff8933,#ff3d3d);box-shadow:0 0 16px rgba(255,120,70,.45) inset}
    .vignette{position:fixed;inset:0;pointer-events:none;background:radial-gradient(60vw 60vh at 50% 70%, rgba(0,0,0,0) 0%, rgba(0,0,0,.18) 70%, rgba(0,0,0,.36) 100%)}
  </style>
</head>
<body>
  <div class="gridOverlay" aria-hidden="true"></div>
  <div class="hud">
    <div class="leftHUD">
      <div class="pill tiny">Score: <span id="score">000000</span></div>
      <div class="pill tiny">Level: <span id="level">1</span></div>
      <div class="pill tiny">Lives: <span id="lives">3</span></div>
      <div class="pill tiny" style="display:flex;align-items:center;gap:6px">
        Shield
        <span class="bar" style="width:110px"><i id="shieldFill"></i></span>
      </div>
      <div class="pill tiny">Combo x<span id="combo">1</span></div>
    </div>
    <div class="rightHUD">
      <div id="pauseBtn" class="pill btn" title="Pause">‚è∏</div>
      <div id="muteBtn" class="pill btn" title="Mute">üîä</div>
    </div>
  </div>

  <div class="bossbar" id="bossbar"><i id="bossFill"></i></div>
  <div class="vignette" aria-hidden="true"></div>

  <div class="touchHints">
    <div class="hint">Drag anywhere to move</div>
    <div class="hint">Auto-fire ON</div>
  </div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h1>Neon Strike: Alien Defense+</h1>
      <p>Drag to move your fighter. Auto-fire is enabled. Dodge, strike, and survive.</p>
      <p>New: enemy formations, asteroids, power-ups (spread, rapid, shield, magnet, drone), combos, and bosses every few waves.</p>
      <p class="sub">Tip: Keep your streak alive to boost score. Boss drops help a lot.</p>
      <button id="startBtn" class="cta">Start Mission</button>
    </div>
  </div>

  <canvas id="c" aria-label="Game Canvas"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      let W = 0, H = 0;

      const state = {
        running: false,
        paused: false,
        muted: false,
        t: 0,
        last: 0,
        score: 0,
        level: 1,
        timeSurvived: 0,
        lives: 3,
        shield: 80,
        shieldMax: 100,
        invuln: 0,
        autofire: true,
        combo: 1,
        streak: 0,
        comboTimer: 0,
        screenShake: 0
      };

      const getVar = name => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

      // Ship and power
      const ship = {
        x: 0, y: 0, r: 16,
        speed: 860,
        targetX: 0,
        fireCd: 0,
        fireRate: 0.22,
        spread: false,
        spreadTimer: 0,
        rapidTimer: 0,
        magnetTimer: 0,
        droneTimer: 0,
        tilt: 0
      };

      // Collections
      let stars = [];
      const bullets = [];
      const enemies = [];
      const eBullets = [];
      const particles = [];
      const powerups = [];
      const asteroids = [];
      let boss = null;
      let bossTimer = 90; // first boss roughly at 1.5 min
      let spawnTimer = 0;
      let formationTimer = 5;

      // UI elements
      const elScore = document.getElementById('score');
      const elLevel = document.getElementById('level');
      const elLives = document.getElementById('lives');
      const elShieldFill = document.getElementById('shieldFill');
      const elCombo = document.getElementById('combo');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const muteBtn = document.getElementById('muteBtn');
      const bossbar = document.getElementById('bossbar');
      const bossFill = document.getElementById('bossFill');

      // Audio (minimal)
      const audioCtx = typeof AudioContext !== 'undefined' ? new AudioContext() : null;
      function beep(freq=440, dur=0.06, vol=0.03, type='square') {
        if (state.muted || !audioCtx) return;
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
        o.connect(g).connect(audioCtx.destination);
        o.start(t); o.stop(t + dur);
      }

      // Resize handling
      function resize() {
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const r = canvas.getBoundingClientRect();
        W = Math.max(320, Math.floor(r.width));
        H = Math.max(320, Math.floor(r.height));
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        buildStars();
        buildNebula();
        ship.x = Math.min(Math.max(ship.x || W * 0.5, 20), W - 20);
        ship.y = H - 90;
        ship.targetX = ship.x;
      }
      window.addEventListener('resize', resize, { passive: true });

      // Background nebula offscreen
      let nebulaCanvas = null;
      function buildNebula() {
        nebulaCanvas = document.createElement('canvas');
        nebulaCanvas.width = Math.max(512, W);
        nebulaCanvas.height = Math.max(512, H);
        const nctx = nebulaCanvas.getContext('2d');
        nctx.clearRect(0,0,nebulaCanvas.width,nebulaCanvas.height);
        // soft nebulas
        for (let i=0;i<3;i++){
          const x = Math.random()*nebulaCanvas.width;
          const y = Math.random()*nebulaCanvas.height*0.8;
          const r = Math.max(W,H) * (0.4+Math.random()*0.6);
          const g = nctx.createRadialGradient(x,y,0,x,y,r);
          const hue = 190 + Math.random()*80;
          g.addColorStop(0, `hsla(${hue},80%,60%,.25)`);
          g.addColorStop(1, `hsla(${hue},80%,60%,0)`);
          nctx.fillStyle = g;
          nctx.beginPath();
          nctx.arc(x,y,r,0,Math.PI*2);
          nctx.fill();
        }
      }

      // Starfield layers
      function buildStars() {
        const count = Math.floor((W * H) / 9000);
        stars = [];
        for (let i = 0; i < count; i++) {
          stars.push({
            x: Math.random() * W,
            y: Math.random() * H,
            z: Math.random() * 1 + 0.2, // depth
            s: Math.random() * 1.5 + 0.2, // size
            tw: Math.random() * 6.28
          });
        }
      }

      // Difficulty tuning for 10-15 min session
      function difficulty() {
        const t = state.timeSurvived;
        const level = 1 + Math.floor(t / 45);
        state.level = Math.min(level, 99);
        const speedScale = 1 + Math.min(t / (14 * 60), 1.0); // up to 2x over ~14min
        const spawnInterval = Math.max(0.24, 1.2 - t / 120); // 1.2s down to 0.24s
        const shooterProb = Math.min(0.4, 0.08 + t / 280);
        const tankProb = Math.min(0.28, 0.06 + t / 360);
        const zigProb = Math.min(0.42, 0.12 + t / 300);
        const asteroidProb = Math.min(0.35, 0.06 + t / 260);
        const bossInterval = Math.max(65, 100 - t / 6); // bosses slightly more frequent over time
        return { speedScale, spawnInterval, shooterProb, tankProb, zigProb, asteroidProb, bossInterval };
      }

      function spawnEnemy(type = null, x = null, y = null) {
        const d = difficulty();
        const r = Math.random();
        if (!type) {
          type = 'normal';
          if (r < d.shooterProb) type = 'shooter';
          else if (r < d.shooterProb + d.tankProb) type = 'tank';
          else if (r < d.shooterProb + d.tankProb + d.zigProb) type = 'interceptor';
        }
        const yy = y ?? (60 + Math.random() * Math.max(120, H * 0.6));
        const speed = (70 + Math.random() * 90) * d.speedScale;
        let hp = 1, radius = 14, shootCd = 0, pattern = Math.random() * 1000, vx = -speed, vy = 0, score = 12;

        switch(type){
          case 'tank': hp = 4; radius = 16; score = 35; break;
          case 'shooter': hp = 2; shootCd = 1.2; radius = 14; score = 24; break;
          case 'interceptor': hp = 1; radius = 12; score = 18; break;
          default: hp = 1; radius = 13; score = 12;
        }

        enemies.push({
          type, x: x ?? (W + 40), y: yy, r: radius, hp, hpMax: hp,
          vx, vy, t: 0, shootCd, pattern, score, sprite: sprites.enemy[type]
        });
      }

      function spawnAsteroid() {
        const size = 16 + Math.random()*18;
        const speed = 60 + Math.random()*70;
        const rot = (Math.random()*2-1)*0.8;
        const hp = Math.round(1 + size/10);
        asteroids.push({
          x: W + 50, y: 40 + Math.random()*(H*0.6), r: size, vx: -speed, vy: (Math.random()*2-1)*20,
          rot: Math.random()*Math.PI*2, vrot: rot, hp, sprite: sprites.asteroid
        });
      }

      function spawnPowerup(x, y, forced=null) {
        if (!forced && Math.random() > 0.18) return;
        const r = Math.random();
        const kinds = ['shield','rapid','spread','magnet','drone'];
        let kind = forced ?? (r < 0.2 ? 'shield' : r < 0.4 ? 'rapid' : r < 0.65 ? 'spread' : r < 0.85 ? 'magnet' : 'drone');
        const vy = 40 + Math.random()*30;
        powerups.push({ x, y, kind, vy, r: 12, t: 0, sprite: sprites.power[kind] });
      }

      function addExplosion(x, y, color, n=14, spread=240) {
        for (let i = 0; i < n; i++) {
          const a = Math.random() * Math.PI * 2;
          const s = Math.random() * spread + 80;
          particles.push({
            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
            life: 0.6 + Math.random() * 0.4,
            t: 0, color, size: 2 + Math.random() * 2, type:'spark'
          });
        }
        // shockwave
        particles.push({x,y,vx:0,vy:0,life:0.35,t:0,color:'rgba(255,255,255,.5)',size:36,type:'wave'});
        state.screenShake = Math.min(14, state.screenShake + Math.min(6, n/2));
      }

      function addThrust() {
        particles.push({
          x: ship.x + (Math.random()*6-3), y: ship.y + ship.r + 4,
          vx: (Math.random()*2-1) * 26, vy: 140 + Math.random()*60,
          life: 0.25 + Math.random()*0.1, t: 0, color: 'rgba(0,220,255,.65)', size: 1.6, type:'ember'
        });
      }

      function addDebris(x,y,dir= -1) {
        for(let i=0;i<6;i++){
          const a = Math.random()*Math.PI*2;
          const sp = 120+Math.random()*140;
          particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.6+Math.random()*0.5,t:0,color:'rgba(120,180,200,.9)',size:1.8,type:'debris'});
        }
      }

      function fireBullet() {
        const nowCd = ship.fireRate * (ship.rapidTimer > 0 ? 0.5 : 1);
        if (ship.fireCd > 0) return;
        ship.fireCd = nowCd;
        const y = ship.y - ship.r - 6;
        const base = { x: ship.x, y, vx: 0, vy: -720, r: 3.5, t:0, color: getVar('--danger'), type:'laser' };
        const lasers = [];
        if (ship.spread || ship.rapidTimer > 0) {
          const angle = 0.24;
          lasers.push({ ...base, vx: -260 * Math.sin(angle), vy: base.vy * Math.cos(angle) });
          lasers.push(base);
          lasers.push({ ...base, vx: 260 * Math.sin(angle), vy: base.vy * Math.cos(angle) });
        } else {
          lasers.push(base);
        }
        if (ship.droneTimer > 0) {
          lasers.push({ ...base, x: ship.x - 20, vy: -700 });
          lasers.push({ ...base, x: ship.x + 20, vy: -700 });
        }
        bullets.push(...lasers);
        beep(520 + Math.random()*20, 0.045, 0.035, 'sawtooth');
      }

      function enemyFire(e) {
        const speed = 300 + Math.random() * 70;
        const angle = Math.atan2((ship.y - e.y), (ship.x - e.x));
        const spread = e.type === 'tank' ? 0.12 : 0.08;
        const count = e.type === 'tank' ? 3 : 2;
        for (let k=0;k<count;k++){
          const off = (k - (count-1)/2) * spread;
          const vx = Math.cos(angle + off) * speed;
          const vy = Math.sin(angle + off) * speed;
          eBullets.push({ x: e.x, y: e.y, vx, vy, r: 3.5, color: '#a96bff' });
        }
        beep(320, 0.05, 0.03, 'triangle');
      }

      // Formations
      function spawnFormation() {
        const d = difficulty();
        const pattern = Math.floor(Math.random()*4);
        const rowY = 80 + Math.random()*(H*0.5);
        if (pattern === 0) {
          // V wedge
          for(let i=0;i<5;i++){
            spawnEnemy('interceptor', W + 60 + i*20, rowY - i*24);
            spawnEnemy('interceptor', W + 60 + i*20, rowY + i*24);
          }
        } else if (pattern === 1) {
          // Line shooters
          for(let i=0;i<4;i++) spawnEnemy('shooter', W + 60 + i*30, rowY + (i%2?30:-30));
        } else if (pattern === 2) {
          // Tanks escort
          spawnEnemy('tank', W + 50, rowY);
          spawnEnemy('interceptor', W + 80, rowY - 40);
          spawnEnemy('interceptor', W + 80, rowY + 40);
        } else {
          // Sine swarm
          for(let i=0;i<6;i++){
            spawnEnemy('normal', W + 50 + i*24, 80 + i*18);
          }
        }
        // occasional asteroid with formations
        if (Math.random() < d.asteroidProb) spawnAsteroid();
      }

      // Boss
      function spawnBoss() {
        const d = difficulty();
        const hpBase = 500 + state.level * 60;
        boss = {
          x: W + 140, y: H*0.45, r: 44, hp: hpBase, hpMax: hpBase,
          vx: -(70 + (d.speedScale-1)*40), vy: 0, phase: 0, t:0, sprite: sprites.boss
        };
        bossbar.style.display = 'block';
        beep(180, 0.25, 0.07, 'square');
      }

      // Input
      let keys = {};
      let pointerId = null;
      function onPointerDown(e) {
        pointerId = e.pointerId;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        ship.targetX = x;
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      }
      function onPointerMove(e) {
        if (pointerId !== null && e.pointerId !== pointerId) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        ship.targetX = x;
      }
      function onPointerUp(e) {
        if (e.pointerId === pointerId) pointerId = null;
      }
      function onKey(e, d) {
        const k = e.key.toLowerCase();
        if (k === 'arrowleft' || k === 'a') keys.left = d;
        if (k === 'arrowright' || k === 'd') keys.right = d;
        if (k === ' ' || k === 'spacebar') { e.preventDefault(); }
        if (k === 'p') togglePause();
        if (k === 'm') toggleMute();
      }
      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('keydown', e => onKey(e, true));
      window.addEventListener('keyup', e => onKey(e, false));

      pauseBtn.addEventListener('click', () => togglePause());
      muteBtn.addEventListener('click', () => toggleMute());
      startBtn.addEventListener('click', () => startGame());

      function togglePause() {
        if (!state.running) return;
        state.paused = !state.paused;
        pauseBtn.textContent = state.paused ? '‚ñ∂' : '‚è∏';
        if (!state.paused) {
          state.last = performance.now();
          requestAnimationFrame(loop);
        }
      }
      function toggleMute() {
        state.muted = !state.muted;
        muteBtn.textContent = state.muted ? 'üîá' : 'üîä';
      }

      function startGame() {
        state.running = true;
        state.paused = false;
        state.t = 0;
        state.last = performance.now();
        state.score = 0;
        state.level = 1;
        state.timeSurvived = 0;
        state.lives = 3;
        state.shield = 90;
        state.invuln = 1.2;
        state.combo = 1; state.streak = 0; state.comboTimer = 0;
        state.screenShake = 0;
        ship.x = W * 0.5; ship.y = H - 90; ship.targetX = ship.x;
        ship.fireCd = 0; ship.spread = false; ship.spreadTimer = 0; ship.rapidTimer = 0; ship.magnetTimer = 0; ship.droneTimer = 0;
        bullets.length = enemies.length = eBullets.length = particles.length = powerups.length = asteroids.length = 0;
        spawnTimer = 0.6;
        formationTimer = 4;
        boss = null;
        const d = difficulty();
        bossTimer = d.bossInterval;
        overlay.classList.add('hidden');
        pauseBtn.textContent = '‚è∏';
        bossbar.style.display = 'none';
        requestAnimationFrame(loop);
      }

      function gameOver() {
        state.running = false;
        boss = null;
        bossbar.style.display = 'none';
        overlay.classList.remove('hidden');
        overlay.innerHTML = `
          <div class="card">
            <h1>Mission Failed</h1>
            <p>Your score: <b>${state.score.toLocaleString()}</b> | Level: <b>${state.level}</b> | Best combo: x<b>${Math.max(1, state.combo)}</b></p>
            <p class="sub">Tip: Keep your streak going and use Magnet + Drone on bosses.</p>
            <button id="restartBtn" class="cta">Try Again</button>
          </div>`;
        const btn = document.getElementById('restartBtn');
        btn.addEventListener('click', () => {
          overlay.innerHTML = `
            <div class="card">
              <h1>Neon Strike: Alien Defense+</h1>
              <p>Drag to move your fighter. Auto-fire is enabled. Dodge, strike, and survive.</p>
              <p>New: enemy formations, asteroids, power-ups (spread, rapid, shield, magnet, drone), combos, and bosses every few waves.</p>
              <p class="sub">Tip: Keep your streak alive to boost score. Boss drops help a lot.</p>
              <button id="startBtn" class="cta">Start Mission</button>
            </div>`;
          document.getElementById('startBtn').addEventListener('click', () => startGame());
        }, { once: true });
      }

      // SPRITES (offscreen, for more detailed look)
      const sprites = { enemy:{}, power:{} };

      function makeCanvas(w,h,draw){
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        const x = c.getContext('2d');
        draw(x,w,h);
        return c;
      }
      function metalGradient(x,w,h, hue=200){
        const g = x.createLinearGradient(0,0,0,h);
        g.addColorStop(0, `hsla(${hue},35%,80%,1)`);
        g.addColorStop(0.5, `hsla(${hue},25%,45%,1)`);
        g.addColorStop(1, `hsla(${hue},30%,70%,1)`);
        return g;
      }

      function buildSprites(){
        // Ship
        sprites.ship = makeCanvas(64,64,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.shadowColor='rgba(0,200,255,.4)'; x.shadowBlur=12;
          // hull
          x.fillStyle = metalGradient(x,w,h,200);
          x.strokeStyle='rgba(0,0,0,.35)'; x.lineWidth=2;
          x.beginPath();
          x.moveTo(0,-22); x.lineTo(-16,16); x.lineTo(16,16); x.closePath();
          x.fill(); x.stroke();
          // wings
          x.fillStyle = metalGradient(x,w,h,210);
          x.beginPath(); x.moveTo(-16,12); x.lineTo(-26,10); x.lineTo(-12,2); x.closePath(); x.fill(); x.stroke();
          x.beginPath(); x.moveTo(16,12); x.lineTo(26,10); x.lineTo(12,2); x.closePath(); x.fill(); x.stroke();
          // cockpit
          const g = x.createLinearGradient(0,-6,0,8);
          g.addColorStop(0,'rgba(150,220,255,.95)');
          g.addColorStop(1,'rgba(30,80,120,.85)');
          x.fillStyle=g;
          x.beginPath(); x.ellipse(0,0,6,8,0,0,Math.PI*2); x.fill(); x.stroke();
          // engine ports
          x.fillStyle='rgba(0,240,255,.8)';
          x.beginPath(); x.arc(-6,18,3,0,Math.PI*2); x.arc(6,18,3,0,Math.PI*2); x.fill();
        });

        // Enemies
        sprites.enemy.normal = makeCanvas(52,52,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.fillStyle = metalGradient(x,w,h,120);
          x.strokeStyle='rgba(0,0,0,.35)'; x.lineWidth=2;
          x.beginPath(); x.roundRect(-16,-10,32,20,6); x.fill(); x.stroke();
          // eye
          x.fillStyle='rgba(0,255,160,.9)'; x.beginPath(); x.arc(0,0,4,0,Math.PI*2); x.fill();
          // fins
          x.fillStyle='rgba(80,140,80,1)';
          x.beginPath(); x.moveTo(-16,0); x.lineTo(-24,-8); x.lineTo(-24,8); x.closePath(); x.fill();
          x.beginPath(); x.moveTo(16,0); x.lineTo(24,-8); x.lineTo(24,8); x.closePath(); x.fill();
        });

        sprites.enemy.shooter = makeCanvas(56,56,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.fillStyle = metalGradient(x,w,h,200);
          x.strokeStyle='rgba(0,0,0,.35)'; x.lineWidth=2;
          x.beginPath(); x.roundRect(-18,-12,36,24,6); x.fill(); x.stroke();
          // turret
          x.fillStyle='rgba(160,210,255,1)';
          x.beginPath(); x.roundRect(-6,-4,12,8,3); x.fill(); x.stroke();
          x.fillStyle='#50b0ff';
          x.fillRect(-2,-16,4,12);
          // lights
          x.fillStyle='#aef';
          x.beginPath(); x.arc(-8,0,3,0,Math.PI*2); x.arc(8,0,3,0,Math.PI*2); x.fill();
        });

        sprites.enemy.tank = makeCanvas(60,60,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.fillStyle = metalGradient(x,w,h,90);
          x.strokeStyle='rgba(0,0,0,.4)'; x.lineWidth=2.2;
          x.beginPath(); x.roundRect(-20,-14,40,28,8); x.fill(); x.stroke();
          // armor plates
          x.fillStyle='rgba(140,180,120,1)'; x.fillRect(-18,-6,36,4); x.fillRect(-18,2,36,4);
          // core
          x.fillStyle='rgba(255,120,80,1)'; x.beginPath(); x.arc(0,0,5,0,Math.PI*2); x.fill();
        });

        sprites.enemy.interceptor = makeCanvas(50,50,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.fillStyle = metalGradient(x,w,h,140);
          x.strokeStyle='rgba(0,0,0,.35)'; x.lineWidth=2;
          x.beginPath(); x.moveTo(0,-16); x.lineTo(-14,10); x.lineTo(14,10); x.closePath(); x.fill(); x.stroke();
          x.fillStyle='rgba(160,255,160,1)'; x.beginPath(); x.arc(0,-2,3,0,Math.PI*2); x.fill();
        });

        // Boss
        sprites.boss = makeCanvas(160,120,(x,w,h)=>{
          x.translate(w/2,h/2);
          x.shadowColor='rgba(255,120,60,.35)'; x.shadowBlur=18;
          x.fillStyle = metalGradient(x,w,h,25);
          x.strokeStyle='rgba(0,0,0,.45)'; x.lineWidth=3;
          x.beginPath(); x.roundRect(-60,-30,120,60,16); x.fill(); x.stroke();
          // nose
          x.beginPath(); x.moveTo(60,-18); x.lineTo(90,0); x.lineTo(60,18); x.closePath(); x.fill(); x.stroke();
          // engines
          x.fillStyle='rgba(255,160,100,1)';
          x.beginPath(); x.arc(-40,26,8,0,Math.PI*2); x.arc(40,26,8,0,Math.PI*2); x.fill();
          // windows
          x.fillStyle='#dff';
          x.fillRect(-14,-8,28,16);
        });

        // Asteroid
        sprites.asteroid = makeCanvas(64,64,(x,w,h)=>{
          x.translate(w/2,h/2);
          const path = new Path2D();
          const pts = [];
          const r=22;
          for(let i=0;i<10;i++){
            const ang = (i/10)*Math.PI*2;
            const rr = r + (Math.random()*10-5);
            pts.push({x:Math.cos(ang)*rr, y:Math.sin(ang)*rr});
          }
          x.fillStyle='#473f3a';
          x.strokeStyle='rgba(0,0,0,.5)'; x.lineWidth=2;
          x.beginPath();
          x.moveTo(pts[0].x, pts[0].y);
          for(let i=1;i<pts.length;i++) x.lineTo(pts[i].x, pts[i].y);
          x.closePath(); x.fill(); x.stroke();
          // craters
          x.fillStyle='rgba(120,110,100,.9)';
          for(let i=0;i<3;i++){ x.beginPath(); x.arc((Math.random()*20-10),(Math.random()*20-10),3+Math.random()*3,0,Math.PI*2); x.fill(); }
        });

        // Powerups
        function powerSprite(colorBase, label){
          return makeCanvas(40,40,(x,w,h)=>{
            x.translate(w/2,h/2);
            const g = x.createRadialGradient(-6,-6,2,0,0,18);
            g.addColorStop(0, colorBase.replace('1)','0.95)'));
            g.addColorStop(1, colorBase.replace('1)','0.25)'));
            x.fillStyle=g; x.strokeStyle='rgba(0,0,0,.35)'; x.lineWidth=2;
            x.beginPath(); x.arc(0,0,14,0,Math.PI*2); x.fill(); x.stroke();
            x.fillStyle='rgba(0,30,40,.95)'; x.font='900 12px system-ui'; x.textAlign='center'; x.textBaseline='middle';
            x.fillText(label,0,1);
          });
        }
        sprites.power.shield = powerSprite('rgba(0,255,220,1)','SH');
        sprites.power.rapid = powerSprite('rgba(80,240,255,1)','RP');
        sprites.power.spread = powerSprite('rgba(90,255,180,1)','SP');
        sprites.power.magnet = powerSprite('rgba(255,220,0,1)','MG');
        sprites.power.drone = powerSprite('rgba(255,140,60,1)','DR');
      }

      function drawSprite(img, x, y, rot=0, scale=1) {
        ctx.save();
        ctx.translate(x,y);
        if (rot) ctx.rotate(rot);
        if (scale !== 1) ctx.scale(scale, scale);
        ctx.drawImage(img, -img.width/2, -img.height/2);
        ctx.restore();
      }

      // Grid overlay texture
      function drawGridTexture() {
        const g = document.querySelector('.gridOverlay');
        const size = 48;
        const c2 = document.createElement('canvas');
        c2.width = size; c2.height = size;
        const x2 = c2.getContext('2d');
        x2.strokeStyle = 'rgba(0, 180, 255, .12)';
        x2.lineWidth = 1;
        x2.beginPath();
        x2.moveTo(size, 0); x2.lineTo(0, 0); x2.lineTo(0, size);
        x2.stroke();
        g.style.backgroundImage = `url(${c2.toDataURL()})`;
        g.style.backgroundSize = `${size}px ${size}px`;
      }

      // Main loop
      function loop(ts) {
        if (!state.running || state.paused) return;
        const dt = Math.min(0.033, (ts - state.last) / 1000 || 0.016);
        state.last = ts;
        state.t += dt;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      function update(dt) {
        // HUD updates
        elScore.textContent = state.score.toString().padStart(6, '0');
        elLevel.textContent = state.level;
        elLives.textContent = state.lives;
        elShieldFill.style.width = (state.shield / state.shieldMax * 100).toFixed(1) + '%';
        elCombo.textContent = Math.max(1, Math.floor(state.combo));

        state.timeSurvived += dt;

        // Input to movement
        let move = 0;
        if (keys.left) move -= 1;
        if (keys.right) move += 1;
        if (move !== 0) {
          ship.targetX = clamp(ship.x + move * ship.speed * 0.12, 16, W - 16);
        }
        const dx = ship.targetX - ship.x;
        ship.x += dx * Math.min(1, dt * 12); // ease
        ship.x = clamp(ship.x, 16, W - 16);
        const desiredTilt = clamp(dx/60, -0.8, 0.8);
        ship.tilt += (desiredTilt - ship.tilt) * Math.min(1, dt * 10);
        ship.y = H - 90;

        // Auto fire
        if (state.autofire) fireBullet();
        ship.fireCd = Math.max(0, ship.fireCd - dt);

        // Power timers
        if (ship.spreadTimer > 0) { ship.spreadTimer -= dt; if (ship.spreadTimer <= 0) ship.spread = false; }
        if (ship.rapidTimer > 0) ship.rapidTimer -= dt;
        if (ship.magnetTimer > 0) ship.magnetTimer -= dt;
        if (ship.droneTimer > 0) ship.droneTimer -= dt;

        // Shield recharge
        if (state.invuln <= 0) state.shield = Math.min(state.shieldMax, state.shield + 6.5 * dt);
        state.invuln = Math.max(0, state.invuln - dt);

        // Combo timer
        state.comboTimer = Math.max(0, state.comboTimer - dt);
        if (state.comboTimer <= 0 && state.streak > 0) {
          state.streak = Math.max(0, state.streak - 1);
          state.combo = 1 + Math.floor(state.streak / 6);
          state.comboTimer = 0.8;
        }

        // Spawning
        const d = difficulty();
        spawnTimer -= dt;
        if (spawnTimer <= 0 && !boss) {
          // random choice: formation or solo enemies
          if (Math.random() < 0.35) spawnFormation();
          else {
            const batch = Math.random() < 0.35 ? 2 : 1;
            for (let i = 0; i < batch; i++) spawnEnemy();
            if (Math.random() < d.asteroidProb) spawnAsteroid();
          }
          spawnTimer = d.spawnInterval * (0.7 + Math.random() * 0.6);
        }
        // formation pacing
        formationTimer -= dt;
        if (formationTimer <= 0 && !boss) {
          spawnFormation();
          formationTimer = 5 + Math.random()*4;
        }

        // Boss timer
        if (!boss) {
          bossTimer -= dt;
          if (bossTimer <= 0) {
            spawnBoss();
            bossTimer = d.bossInterval;
          }
        }

        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.t += dt;
          if (e.type === 'interceptor') {
            e.vy = Math.sin(e.t * 4 + e.pattern) * 90;
          } else if (e.type === 'normal') {
            e.vy = Math.sin((e.t + e.pattern) * 1.6) * 30;
          } else {
            e.vy *= 0.98; // damp
          }
          e.x += e.vx * dt;
          e.y += e.vy * dt;

          // Shooters & tanks fire
          if (e.type === 'shooter' || e.type === 'tank') {
            e.shootCd -= dt;
            if (e.shootCd <= 0 && e.x < W - 80) {
              e.shootCd = (e.type === 'tank' ? 1.4 : 1.1) + Math.random() * 0.5;
              enemyFire(e);
            }
          }

          // Passed through
          if (e.x < -e.r - 20) {
            enemies.splice(i, 1);
            damagePlayer(1, false);
            continue;
          }
        }

        // Update asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const a = asteroids[i];
          a.x += a.vx * dt;
          a.y += a.vy * dt;
          a.rot += a.vrot * dt;
          if (a.x < -60 || a.y < -40 || a.y > H + 40) asteroids.splice(i,1);
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.t += dt;
          b.x += b.vx * dt; b.y += b.vy * dt;
          if (b.y < -20 || b.x < -20 || b.x > W + 20) {
            bullets.splice(i, 1);
          }
        }

        // Update enemy bullets
        for (let i = eBullets.length - 1; i >= 0; i--) {
          const b = eBullets[i];
          b.x += b.vx * dt; b.y += b.vy * dt;
          if (b.y > H + 30 || b.x < -30 || b.x > W + 30) eBullets.splice(i, 1);
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.t += dt;
          if (p.type === 'wave') {
            // nothing, size scales in draw
          } else {
            p.x += p.vx * dt; p.y += p.vy * dt;
            p.vx *= 0.985; p.vy *= 0.985;
          }
          if (p.t > p.life) particles.splice(i, 1);
        }
        if (Math.abs(dx) > 2 && Math.random() < 0.9) addThrust();
        if (particles.length > 900) particles.splice(0, particles.length - 900);

        // Powerups
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          p.t += dt;
          // magnet attraction
          if (ship.magnetTimer > 0) {
            const ddx = ship.x - p.x, ddy = ship.y - p.y;
            const d2 = ddx*ddx + ddy*ddy;
            if (d2 < 200*200) {
              const a = Math.atan2(ddy, ddx);
              const pull = 180 / Math.max(60, Math.sqrt(d2));
              p.x += Math.cos(a) * pull;
              p.y += Math.sin(a) * pull;
            } else {
              p.y += p.vy * dt;
            }
          } else {
            p.y += p.vy * dt;
          }
          if (p.y > H + 20) powerups.splice(i, 1);
        }

        // Boss update
        if (boss) {
          boss.t += dt;
          boss.x += boss.vx * dt;
          boss.y += Math.sin(boss.t*1.2) * 30 * dt;
          if (boss.x < W - 140) boss.vx = 0; // enter then hover
          // Patterns
          if (boss.t % 2.4 < dt) {
            // burst
            const shots = 8;
            for(let k=0;k<shots;k++){
              const ang = Math.atan2(ship.y - boss.y, ship.x - boss.x) + (k - shots/2)*(Math.PI/24);
              const sp = 320;
              eBullets.push({x:boss.x, y:boss.y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:4, color:'#ff7b4a' });
            }
            beep(220, 0.08, 0.05, 'square');
          }
          if (boss.t % 1.1 < dt) {
            // aimed
            const ang = Math.atan2(ship.y - boss.y, ship.x - boss.x);
            const sp = 420;
            eBullets.push({x:boss.x-30, y:boss.y+10, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:3.8, color:'#ffa35a' });
            eBullets.push({x:boss.x+30, y:boss.y+10, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:3.8, color:'#ffa35a' });
          }
          // Boss hp bar
          bossFill.style.width = (Math.max(0, boss.hp) / boss.hpMax * 100).toFixed(1) + '%';
          if (boss.hp <= 0) {
            addExplosion(boss.x, boss.y, 'rgba(255,120,80,.9)', 48, 560);
            addDebris(boss.x, boss.y);
            for(let i=0;i<4;i++) spawnPowerup(boss.x + (Math.random()*80-40), boss.y + (Math.random()*40-20), i%2 ? 'shield' : (i%3?'spread':'rapid'));
            state.score += Math.floor(600 * state.combo);
            boss = null;
            bossbar.style.display = 'none';
            beep(140, 0.2, 0.07, 'sawtooth');
          }
        }

        // Collisions: bullets vs enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx2 = e.x - b.x, dy2 = e.y - b.y;
            const rr = (e.r + b.r) * (e.r + b.r);
            if (dx2*dx2 + dy2*dy2 <= rr) {
              bullets.splice(j, 1);
              e.hp -= 1;
              addExplosion(b.x, b.y, 'rgba(255,140,160,.6)', 4, 120);
              if (e.hp <= 0) {
                enemies.splice(i, 1);
                const bonus = Math.floor(e.score * state.combo);
                state.score += bonus;
                state.streak += 1;
                state.combo = 1 + Math.floor(state.streak / 6);
                state.comboTimer = 3;
                addExplosion(e.x, e.y, 'rgba(140,255,120,.85)', 14, 280);
                spawnPowerup(e.x, e.y);
                addDebris(e.x, e.y);
                beep(700, 0.06, 0.045, 'sawtooth');
                if (navigator.vibrate) navigator.vibrate(10);
              } else {
                beep(560, 0.03, 0.03, 'triangle');
              }
              break;
            }
          }
        }

        // Collisions: bullets vs asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const a = asteroids[i];
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx2 = a.x - b.x, dy2 = a.y - b.y;
            const rr = (a.r + b.r) * (a.r + b.r);
            if (dx2*dx2 + dy2*dy2 <= rr) {
              bullets.splice(j, 1);
              a.hp -= 1;
              addExplosion(b.x, b.y, 'rgba(200,200,200,.6)', 3, 90);
              if (a.hp <= 0) {
                asteroids.splice(i,1);
                state.score += Math.floor(10 * state.combo);
                if (Math.random()<0.25) spawnPowerup(a.x,a.y,'shield');
                addExplosion(a.x, a.y, 'rgba(200,200,200,.9)', 10, 300);
              }
              break;
            }
          }
        }

        // Collisions: bullets vs boss
        if (boss) {
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx2 = boss.x - b.x, dy2 = boss.y - b.y;
            const rr = (boss.r + b.r) * (boss.r + b.r);
            if (dx2*dx2 + dy2*dy2 <= rr) {
              bullets.splice(j,1);
              boss.hp -= 3;
              addExplosion(b.x, b.y, 'rgba(255,180,120,.6)', 4, 120);
              beep(500, 0.025, 0.03, 'triangle');
            }
          }
        }

        // Collisions: enemy bullets vs ship
        for (let i = eBullets.length - 1; i >= 0; i--) {
          const b = eBullets[i];
          const dx3 = ship.x - b.x, dy3 = ship.y - b.y;
          const rr = (ship.r + b.r) * (ship.r + b.r);
          if (dx3*dx3 + dy3*dy3 <= rr) {
            eBullets.splice(i, 1);
            damagePlayer(1, true);
          }
        }

        // Collisions: enemies vs ship
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const dx4 = ship.x - e.x, dy4 = ship.y - e.y;
          const rr = (ship.r + e.r) * (ship.r + e.r);
          if (dx4*dx4 + dy4*dy4 <= rr) {
            enemies.splice(i, 1);
            addExplosion(e.x, e.y, 'rgba(255,120,160,.8)', 14, 320);
            damagePlayer(2, true);
          }
        }

        // Collisions: asteroids vs ship
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const a = asteroids[i];
          const dx5 = ship.x - a.x, dy5 = ship.y - a.y;
          const rr = (ship.r + a.r) * (ship.r + a.r);
          if (dx5*dx5 + dy5*dy5 <= rr) {
            asteroids.splice(i,1);
            addExplosion(a.x, a.y, 'rgba(200,200,200,.9)', 12, 360);
            damagePlayer(2, true);
          }
        }

        // Powerup pickup
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          const dx6 = ship.x - p.x, dy6 = ship.y - p.y;
          const rr = (ship.r + p.r) * (ship.r + p.r);
          if (dx6*dx6 + dy6*dy6 <= rr) {
            powerups.splice(i, 1);
            if (p.kind === 'shield') {
              state.shield = Math.min(state.shieldMax, state.shield + 55);
              addExplosion(ship.x, ship.y, 'rgba(0,255,220,.8)', 12, 180);
            } else if (p.kind === 'rapid') {
              ship.rapidTimer = 12;
              addExplosion(ship.x, ship.y, 'rgba(0,220,255,.8)', 10, 220);
            } else if (p.kind === 'spread') {
              ship.spread = true; ship.spreadTimer = 14;
              addExplosion(ship.x, ship.y, 'rgba(90,255,180,.8)', 10, 220);
            } else if (p.kind === 'magnet') {
              ship.magnetTimer = 14;
              addExplosion(ship.x, ship.y, 'rgba(255,230,90,.8)', 10, 220);
            } else if (p.kind === 'drone') {
              ship.droneTimer = 16;
              addExplosion(ship.x, ship.y, 'rgba(255,160,100,.8)', 10, 220);
            }
            state.score += Math.floor(10 * state.combo);
            beep(900, 0.07, 0.05, 'sine');
            if (navigator.vibrate) navigator.vibrate(8);
          }
        }

        // End game?
        if (state.lives <= 0) gameOver();

        // Shake
        state.screenShake = Math.max(0, state.screenShake - 40*dt);
      }

      function damagePlayer(amount, fromHit) {
        if (state.invuln > 0) return;
        let remaining = amount;
        if (state.shield > 0) {
          const absorbed = Math.min(state.shield, remaining * 25);
          state.shield -= absorbed;
          remaining -= absorbed / 25;
        }
        if (remaining > 0.2) {
          state.lives -= 1;
          elLives.textContent = state.lives;
          addExplosion(ship.x, ship.y, 'rgba(255,60,80,.9)', 24, 420);
          beep(180, 0.12, 0.06, 'sawtooth');
          state.invuln = 1.2;
          state.streak = 0; state.combo = 1; state.comboTimer = 0;
          if (navigator.vibrate) navigator.vibrate([20,40,60]);
        } else {
          beep(260, 0.05, 0.04, 'triangle');
        }
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function draw() {
        ctx.clearRect(0, 0, W, H);

        // background nebula
        if (nebulaCanvas) ctx.drawImage(nebulaCanvas, 0, 0, nebulaCanvas.width, nebulaCanvas.height, 0, 0, W, H);

        // Parallax stars
        ctx.save();
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          s.x -= (22 + 80 * s.z) * (1/60);
          if (s.x < -2) s.x += W + 2;
          s.tw += 0.03 * s.z;
          const twinkle = 0.5 + Math.abs(Math.sin(s.tw)) * 0.5;
          ctx.fillStyle = `rgba(200,240,255,${0.2 + 0.55 * s.z * twinkle})`;
          ctx.fillRect(s.x, s.y, s.s, s.s);
        }
        ctx.restore();

        // camera shake
        if (state.screenShake > 0) {
          ctx.save();
          ctx.translate((Math.random()*2-1)*state.screenShake, (Math.random()*2-1)*state.screenShake);
        }

        // Draw asteroids
        for (const a of asteroids) {
          ctx.save();
          ctx.translate(a.x, a.y);
          ctx.rotate(a.rot);
          const sc = clamp(a.r/22, 0.8, 1.6);
          ctx.scale(sc, sc);
          ctx.shadowColor='rgba(80,80,80,.4)';
          ctx.shadowBlur=12;
          ctx.drawImage(a.sprite, -a.sprite.width/2, -a.sprite.height/2);
          ctx.restore();
        }

        // Draw enemies
        for (const e of enemies) {
          const img = e.sprite || sprites.enemy.normal;
          const wob = (e.type==='interceptor'? Math.sin(e.t*8)*0.1 : 0);
          drawSprite(img, e.x, e.y, wob, 0.8 + (e.r/20)*0.4);
          if (e.hp > 1) {
            ctx.fillStyle = 'rgba(0,0,0,.3)';
            ctx.fillRect(e.x - e.r, e.y - e.r - 10, e.r * 2, 4);
            ctx.fillStyle = 'rgba(255,255,255,.85)';
            ctx.fillRect(e.x - e.r, e.y - e.r - 10, (e.r * 2) * (e.hp / e.hpMax), 4);
          }
        }

        // Draw enemy bullets
        for (const b of eBullets) {
          ctx.save();
          const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r*3);
          g.addColorStop(0, b.color.replace(')', ',.95)').replace('rgb(', 'rgba('));
          g.addColorStop(1, b.color.replace(')', ',0)').replace('rgb(', 'rgba('));
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r*1.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw bullets (lasers)
        for (const b of bullets) {
          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(Math.atan2(b.vy, b.vx) - Math.PI/2);
          const grad = ctx.createLinearGradient(0,-10,0,10);
          grad.addColorStop(0,'rgba(255,200,220,.1)');
          grad.addColorStop(0.3,'rgba(255,120,140,.95)');
          grad.addColorStop(1,'rgba(255,60,90,.0)');
          ctx.fillStyle = grad;
          ctx.fillRect(-2, -10, 4, 18);
          ctx.restore();
        }

        // Draw powerups
        for (const p of powerups) {
          const sc = 0.9 + Math.sin((state.t + p.t)*4)*0.05;
          drawSprite(p.sprite, p.x, p.y, 0, sc);
        }

        // Draw particles
        for (const p of particles) {
          const a = 1 - (p.t / p.life);
          if (p.type === 'wave') {
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${a*0.35})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size*(1 + p.t/p.life*2.2), 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.fillStyle = p.color.replace(')', `,${Math.max(0, Math.min(1, a))})`).replace('rgb(', 'rgba(');
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Draw boss
        if (boss) {
          drawSprite(sprites.boss, boss.x, boss.y, Math.sin(state.t*0.8)*0.02, 1);
          // subtle glow
          ctx.save();
          const g = ctx.createRadialGradient(boss.x, boss.y, 0, boss.x, boss.y, boss.r*1.8);
          g.addColorStop(0,'rgba(255,120,60,.15)');
          g.addColorStop(1,'rgba(255,120,60,0)');
          ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(boss.x,boss.y,boss.r*1.8,0,Math.PI*2); ctx.fill();
          ctx.restore();
        }

        // Draw shield aura when invulnerable
        if (state.invuln > 0) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,.08)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 8]);
          ctx.beginPath();
          ctx.arc(ship.x, ship.y, ship.r + 18 + Math.sin(state.t * 6) * 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Draw ship
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.tilt * 0.6);
        ctx.shadowColor = 'rgba(0,220,255,.55)';
        ctx.shadowBlur = 18;
        drawSprite(sprites.ship, 0, 0, 0, 1);
        // engine glow
        const glow = 7 + Math.random() * 6;
        const grad = ctx.createRadialGradient(0, ship.r + 10, 0, 0, ship.r + 10, glow);
        grad.addColorStop(0, 'rgba(0,240,255,.9)');
        grad.addColorStop(1, 'rgba(0,240,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, ship.r + 10, glow, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (state.screenShake > 0) ctx.restore();
      }

      // Kick things off with menu visible but canvas ready
      window.addEventListener('contextmenu', e => e.preventDefault());
      canvas.tabIndex = 1;

      // Build assets and prepare
      drawGridTexture();
      buildSprites();
      resize();

      requestAnimationFrame(() => {
        // idle draw
        ctx.clearRect(0,0,W,H);
      });
    })();
  </script>
</body>
</html>