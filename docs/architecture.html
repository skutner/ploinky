<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture - Ploinky</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="logo">
                    <div class="logo-icon">🚀</div>
                    <span>Ploinky</span>
                </a>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="cli-reference.html">CLI Reference</a></li>
                        <li><a href="architecture.html" class="active">Architecture</a></li>
                        <li><a href="spec-agent.html">Agent Spec</a></li>
                        <li><a href="webchat.html">WebChat</a></li>
                        <li><a href="spec-webmeet.html">WebMeet</a></li>
                        <li><button class="theme-toggle" id="themeToggle">🌙</button></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <main>
        <div class="container">
            <div class="doc-layout">
                <aside class="sidebar">
                    <h3>Architecture Components</h3>
                    <ul>
                        <li><a href="#overview">System Overview</a></li>
                        <li><a href="#core">Core Components</a></li>
                        <li><a href="#containers">Container Management</a></li>
                        <li><a href="#routing">Routing Server</a></li>
                        <li><a href="#workspace">Workspace System</a></li>
                        <li><a href="#security">Security Model</a></li>
                        <li><a href="#web-services">Web Services</a></li>
                        <li><a href="#agent-mcp">Agent MCP Bridge</a></li>
                    </ul>
                </aside>

                <div class="content-wrapper">
                    <div class="doc-section">
                        <h1>Ploinky Architecture</h1>
                        <p class="subtitle">Technical architecture and implementation details of the Ploinky AI agent deployment system.</p>
                    </div>

                    <div class="doc-section" id="overview">
                        <h2>System Overview</h2>
                        <p>Ploinky is built as a modular system with clear separation of concerns:</p>
                        
                        <pre><code>┌─────────────────────────────────────────────────────────┐
│                     User Interface                       │
│  (CLI Commands / Web Console / Chat / Dashboard)         │
└─────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────┐
│                    Ploinky CLI Core                      │
│  (Command Handler / Service Manager / Config)            │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ Routing Server│   │  Web Services │   │Container Mgmt │
│   (HTTP API)  │   │  (WebTTY/Chat)│   │ (Docker/Podman)│
└───────────────┘   └───────────────┘   └───────────────┘
        │                   │                   │
┌─────────────────────────────────────────────────────────┐
│                    Agent Containers                      │
│         (Isolated Linux containers per agent)            │
└─────────────────────────────────────────────────────────┘</code></pre>

                        <h3>Key Design Principles</h3>
                        <ul style="margin-left: 2rem;">
                            <li><strong>Isolation First:</strong> Every agent runs in its own container</li>
                            <li><strong>Workspace Scoped:</strong> All configuration is local to the project directory</li>
                            <li><strong>Zero Global State:</strong> No system-wide installation or configuration</li>
                            <li><strong>Git-Friendly:</strong> Configuration stored in .ploinky folder, can be gitignored</li>
                            <li><strong>Runtime Agnostic:</strong> Supports Docker and Podman transparently</li>
                        </ul>
                    </div>

                    <div class="doc-section" id="core">
                        <h2>Core Components</h2>
                        
                        <h3>CLI Command System (cli/commands/cli.js)</h3>
                        <p>The main entry point that handles all user commands:</p>
                        <pre><code>// Command routing structure
handleCommand(args) {
    switch(command) {
        case 'add':      // Repository management
        case 'enable':   // Agent/repo activation
        case 'start':    // Workspace initialization
        case 'shell':    // Interactive container access
        case 'webchat':  // Web interface launchers
        // ... more commands
    }
}</code></pre>

                        <h3>Service Layer (cli/services/)</h3>
                        <table class="command-table">
                            <tr>
                                <th>Service</th>
                                <th>Responsibility</th>
                            </tr>
                            <tr>
                                <td><code>workspace.js</code></td>
                                <td>Manages .ploinky directory and configuration</td>
                            </tr>
                            <tr>
                                <td><code>docker.js</code></td>
                                <td>Container lifecycle management (Docker/Podman)</td>
                            </tr>
                            <tr>
                                <td><code>repos.js</code></td>
                                <td>Repository management and agent discovery</td>
                            </tr>
                            <tr>
                                <td><code>agents.js</code></td>
                                <td>Agent registration and configuration</td>
                            </tr>
                            <tr>
                                <td><code>secretVars.js</code></td>
                                <td>Environment variable and secrets management</td>
                            </tr>
                            <tr>
                                <td><code>config.js</code></td>
                                <td>Global configuration constants</td>
                            </tr>
                            <tr>
                                <td><code>help.js</code></td>
                                <td>Help system and documentation</td>
                            </tr>
                        </table>
                    </div>

                    <div class="doc-section" id="containers">
                        <h2>Container Management</h2>
                        
                        <h3>Container Lifecycle</h3>
                        <p>Ploinky manages containers with specific naming conventions and lifecycle hooks:</p>
                        
                        <pre><code>// Container naming convention
function getAgentContainerName(agentName, repoName) {
    const proj = path.basename(process.cwd()).replace(/[^a-zA-Z0-9_.-]/g, '_');
    const wsid = crypto.createHash('sha256')
        .update(process.cwd())
        .digest('hex')
        .substring(0, 6);
    return `ploinky_${proj}_${wsid}_agent_${agentName}`;
}

// Service container (for API endpoints)
function getServiceContainerName(agentName) {
    // Similar but with _service_ prefix
    return `ploinky_${proj}_${wsid}_service_${agentName}`;
}</code></pre>

                        <h3>Volume Mounts</h3>
                        <p>Each container gets specific volume mounts for security:</p>
                        <pre><code>{
    binds: [
        { source: process.cwd(), target: process.cwd() },      // Workspace
        { source: '/Agent', target: '/Agent' },                // Agent runtime
        { source: agentPath, target: '/code' }                 // Agent code
    ]
}</code></pre>

                        <h3>Runtime Detection</h3>
                        <p>Automatically detects and uses available container runtime:</p>
                        <pre><code>function getRuntime() {
    try {
        execSync('docker --version', { stdio: 'ignore' });
        return 'docker';
    } catch {
        try {
            execSync('podman --version', { stdio: 'ignore' });
            return 'podman';
        } catch {
            throw new Error('No container runtime found');
        }
    }
}</code></pre>
                    </div>

                    <div class="doc-section" id="routing">
                        <h2>Routing Server</h2>
                        
                        <h3>Purpose</h3>
                        <p>The RoutingServer (cli/server/RoutingServer.js) acts as a reverse proxy, routing API requests to appropriate agent containers:</p>
                        
                        <pre><code>// routing.json structure
{
    "port": 8088,
    "static": {
        "agent": "demo",
        "container": "ploinky_myproject_abc123_service_demo",
        "hostPath": "/path/to/demo/agent"
    },
    "routes": {
        "agent1": {
            "container": "ploinky_myproject_abc123_service_agent1",
            "hostPort": 7001
        },
        "agent2": {
            "container": "ploinky_myproject_abc123_service_agent2",
            "hostPort": 7002
        }
    }
}</code></pre>

                        <h3>Request Flow</h3>
                        <ol style="margin-left: 2rem;">
                            <li>Client sends request to <code>http://localhost:8088/apis/agent1/method</code></li>
                            <li>RoutingServer extracts agent name from path</li>
                            <li>Looks up agent's container port in routing.json</li>
                            <li>Proxies request to <code>http://localhost:7001/api/method</code></li>
                            <li>Returns response to client</li>
                        </ol>

                        <h3>Static File Serving</h3>
                        <p>The router serves static files from the host filesystem in two ways:</p>
                        <ul>
                            <li><strong>Static agent root</strong> (existing): requests like <code>/index.html</code> map to <code>static.hostPath</code> in <code>routing.json</code>.</li>
                            <li><strong>Agent-specific static routing</strong> (new): requests like <code>/demo/ui/index.html</code> map to the <code>hostPath</code> of the <code>demo</code> agent from <code>routes.demo.hostPath</code>.</li>
                        </ul>
                        <pre><code>// Static agent root
GET /index.html            → routing.static.hostPath/index.html
GET /assets/app.js         → routing.static.hostPath/assets/app.js

// Agent-specific static routing
GET /demo/ui/index.html    → routing.routes.demo.hostPath/ui/index.html
GET /simulator/app.js      → routing.routes.simulator.hostPath/app.js</code></pre>

                        <h3>Blob Storage API</h3>
                        <p>The router exposes a simple blob storage API for large files with streaming upload/download.</p>
                        <pre><code>// Upload (streaming)
POST /blobs
Headers:
  Content-Type: application/octet-stream
  X-Mime-Type: text/plain   # optional; falls back to Content-Type
Body: raw bytes (streamed)

Response: 201 Created
{ "id": "<uid>", "url": "/blobs/<uid>", "size": N, "mime": "text/plain" }

// Download (streaming, supports Range)
GET /blobs/&lt;id&gt;
HEAD /blobs/&lt;id&gt;
 - Streams bytes from .ploinky/blobs/&lt;id&gt; with metadata from .ploinky/blobs/&lt;id&gt;.json
 - Sets Content-Type, Content-Length, Accept-Ranges, and supports partial responses (206)</code></pre>
                    </div>

                    <div class="doc-section" id="workspace">
                        <h2>Workspace System</h2>
                        
                        <h3>Directory Structure</h3>
                        <pre><code>.ploinky/
├── agents/              # Agent registry (JSON)
├── repos/               # Cloned agent repositories
│   ├── basic/
│   │   ├── shell/
│   │   │   └── manifest.json
│   │   └── node-dev/
│   │       └── manifest.json
│   ├── demo/
│   │   ├── demo/
│   │   └── simulator/
│   └── custom-repo/
├── routing.json         # Router configuration
├── .secrets            # Environment variables
├── logs/               # Application logs
│   ├── router.log
│   └── webtty.log
└── running/            # Process PID files
    ├── router.pid
    ├── webtty.pid
    ├── webchat.pid
    └── dashboard.pid</code></pre>

                        <h3>Agent Registry (agents/)</h3>
                        <p>JSON file storing enabled agents and their configuration:</p>
                        <pre><code>{
    "ploinky_project_abc123_agent_demo": {
        "agentName": "demo",
        "repoName": "demo",
        "containerImage": "node:18-alpine",
        "createdAt": "2024-01-01T00:00:00Z",
        "projectPath": "/home/user/project",
        "type": "agent",
        "config": {
            "binds": [...],
            "env": [...],
            "ports": [{"containerPort": 7000}]
        }
    }
}</code></pre>

                        <h3>Configuration Management</h3>
                        <p>Workspace configuration persists across sessions:</p>
                        <pre><code>// Stored in agents/_config
{
    "static": {
        "agent": "demo",
        "port": 8088
    }
}</code></pre>
                    </div>

                    <div class="doc-section" id="security">
                        <h2>Security Model</h2>
                        
                        <h3>Container Isolation</h3>
                        <ul style="margin-left: 2rem;">
                            <li><strong>Filesystem:</strong> Containers only access current workspace directory</li>
                            <li><strong>Network:</strong> Isolated network namespace per container</li>
                            <li><strong>Process:</strong> No access to host processes</li>
                            <li><strong>Resources:</strong> Can set CPU/memory limits</li>
                        </ul>

                        <h3>Secret Management</h3>
                        <p>Environment variables stored in .ploinky/.secrets with aliasing support:</p>
                        <pre><code>API_KEY=sk-123456789
PROD_KEY=$API_KEY        # Alias reference
DATABASE_URL=postgres://localhost/db</code></pre>

                        <h3>Web Access Control</h3>
                        <ul style="margin-left: 2rem;">
                            <li>Password protection for web interfaces</li>
                            <li>Session-based authentication</li>
                            <li>WebSocket token validation</li>
                            <li>CORS headers configuration</li>
                        </ul>
                    </div>

                    <div class="doc-section" id="web-services">
                        <h2>Web Services Architecture</h2>
                        
                        <h3>WebTTY/Console (cli/webtty/)</h3>
                        <p>Provides terminal access through web browser:</p>
                        <pre><code>// Component structure
server.js       // HTTP/WebSocket server
tty.js          // PTY management
console.js      // Client-side terminal UI
clientloader.js // Dynamic UI loader</code></pre>

                        <h3>WebChat (cli/webtty/chat.js)</h3>
                        <p>Chat interface for CLI programs:</p>
                        <ul style="margin-left: 2rem;">
                            <li>Captures stdout/stdin through PTY</li>
                            <li>WebSocket-based real-time communication</li>
                            <li>WhatsApp-style UI with message bubbles</li>
                            <li>Automatic reconnection handling</li>
                        </ul>

                        <h3>Dashboard (dashboard/)</h3>
                        <p>Management interface components:</p>
                        <pre><code>landingPage.js      // Main dashboard UI
auth.js             // Authentication
repositories.js     // Repo management
configurations.js   // Settings management
observability.js    // Monitoring views</code></pre>

                        <h3>WebSocket Protocol</h3>
                        <pre><code>// Message types
{ type: 'input', data: 'user command' }     // User input
{ type: 'output', data: 'program output' }  // Program output
{ type: 'resize', cols: 80, rows: 24 }      // Terminal resize
{ type: 'ping' }                             // Keep-alive</code></pre>
                    </div>

                    <div class="doc-section" id="data-flow">
                        <h2>Data Flow Examples</h2>
                        
                        <h3>Starting an Agent</h3>
                        <pre><code>1. User: enable agent demo
   → Find manifest in repos/demo/demo/manifest.json
   → Register in .ploinky/agents
   → Generate container name

2. User: start demo 8088
   → Read agents registry
   → Start container for each agent
   → Map ports (container:7000 → host:7001)
   → Update routing.json
   → Start RoutingServer on 8088

3. Container startup:
   → Pull image if needed
   → Mount volumes (workspace, code, Agent)
   → Set environment variables
   → Run agent command or supervisor</code></pre>

                        <h3>API Request Routing</h3>
                        <pre><code>1. Client: GET http://localhost:8088/apis/simulator/monty-hall
   
2. RoutingServer:
   → Extract agent: "simulator"
   → Lookup in routing.json: hostPort: 7002
   → Proxy to: http://localhost:7002/api/monty-hall
   
3. Agent Container:
   → Process request
   → Return response
   
4. RoutingServer:
   → Forward response to client</code></pre>

                        <h3>WebChat Session</h3>
                        <pre><code>1. User: webchat secret python bot.py
   
2. WebTTY Server:
   → Start PTY with command: python bot.py
   → Create HTTP server on port 8080
   → Serve chat.html interface
   
3. Browser connects:
   → WebSocket handshake
   → Authenticate with password
   → Establish bidirectional channel
   
4. Message flow:
   → User types in chat
   → WebSocket → Server → PTY stdin
   → Program output → PTY stdout → WebSocket → Browser
   → Display as chat bubble</code></pre>
                    </div>

                    <div class="doc-section" id="agent-mcp">
                        <h2>Agent MCP Bridge</h2>
                        <p>AgentServer (Agent/server/AgentServer.mjs) expune capabilități prin <strong>Model Context Protocol (MCP)</strong> folosind transport <em>Streamable HTTP</em> la ruta <code>/mcp</code> pe portul containerului (implicit 7000).</p>

                        <h3>Router ↔ Agent Communication</h3>
                        <ul style="margin-left: 2rem;">
                            <li><strong>RouterServer abstraction:</strong> RouterServer talks to agents through <code>cli/server/AgentClient.js</code>, which wraps MCP transports.</li>
                            <li><strong>MCP protocol:</strong> AgentClient builds a <code>StreamableHTTPClientTransport</code> towards <code>http://127.0.0.1:&lt;hostPort&gt;/mcp</code> and exposes <code>listTools()</code>, <code>callTool()</code>, <code>listResources()</code>, and <code>readResource()</code>.</li>
                            <li><strong>Unified routing:</strong> Requests hitting <code>/mcp</code> carry commands such as <code>list_tools</code>, <code>list_resources</code>, or <code>tool</code>. RouterServer fans these calls out to every registered MCP endpoint and aggregates the replies.</li>
                            <li><strong>Per-agent routes:</strong> Legacy paths like <code>/mcps/&lt;agent&gt;</code> remain available for direct calls when needed.</li>
                            <li><strong>Transport independence:</strong> RouterServer stays agnostic of protocol details; AgentClient encapsulates the MCP implementation.</li>
                        </ul>

                        <h3>Tools and Resources</h3>
                        <p>Agents declare their MCP surface through a JSON file committed alongside the agent source code: <code>.ploinky/repos/&lt;repo&gt;/&lt;agent&gt;/mcp-config.json</code>. When the CLI boots an agent container it copies this file to <code>/tmp/ploinky/mcp-config.json</code> (also keeping <code>/code/mcp-config.json</code> for reference). The file can expose tools, resources, and prompts, and each tool is executed by spawning a shell command. AgentServer does not register anything if the configuration file is missing.</p>
                        <pre><code>{
  "tools": [
    {
      "name": "list_things",
      "title": "List Things",
      "description": "Enumerate items in a category",
      "command": "node scripts/list-things.js",
      "input": {
        "type": "object",
        "properties": {
          "category": {
            "type": "string",
            "description": "fruits | animals | colors"
          }
        },
        "required": ["category"],
        "additionalProperties": false
      }
    }
  ],
  "resources": [
    {
      "name": "health",
      "uri": "health://status",
      "description": "Service health state",
      "mimeType": "application/json",
      "command": "node scripts/health.js"
    }
  ],
  "prompts": [
    {
      "name": "summarize",
      "description": "Short summary",
      "messages": [
        { "role": "system", "content": "You are a concise analyst." },
        { "role": "user", "content": "${input}" }
      ]
    }
  ]
}</code></pre>
                        <p>AgentServer pipes a JSON payload to each command via stdin. Tool invocations receive <code>{ tool, input, metadata }</code>; resources receive <code>{ resource, uri, params }</code>. Command stdout is forwarded to the MCP response, while non-zero exit codes surface as MCP errors.</p>
                    </div>

                    <div class="doc-section">
                        <h2>Performance Considerations</h2>
                        
                        <h3>Container Optimization</h3>
                        <ul style="margin-left: 2rem;">
                            <li>Reuse existing containers when possible</li>
                            <li>Lazy image pulling</li>
                            <li>Shared base layers between agents</li>
                            <li>Volume mount caching</li>
                        </ul>

                        <h3>Network Efficiency</h3>
                        <ul style="margin-left: 2rem;">
                            <li>Local port mapping avoids network overhead</li>
                            <li>HTTP keep-alive for persistent connections</li>
                            <li>WebSocket for real-time communication</li>
                            <li>Request buffering and batching</li>
                        </ul>

                        <h3>Resource Management</h3>
                        <ul style="margin-left: 2rem;">
                            <li>Automatic container cleanup on exit</li>
                            <li>PID file tracking for process management</li>
                            <li>Log rotation for long-running services</li>
                            <li>Memory-efficient streaming for large outputs</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 Ploinky Project. Built with security and simplicity in mind.</p>
            <p>
                <a href="https://github.com/ploinky/ploinky">GitHub</a> • 
                <a href="index.html">Home</a> • 
                <a href="cli-reference.html">CLI Reference</a>
            </p>
        </div>
    </footer>

    <script>
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;
        
        const savedTheme = localStorage.getItem('theme') || 'light';
        body.setAttribute('data-theme', savedTheme);
        themeToggle.textContent = savedTheme === 'dark' ? '☀️' : '🌙';
        
        themeToggle.addEventListener('click', () => {
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? '☀️' : '🌙';
        });

        // Highlight active section in sidebar
        const sections = document.querySelectorAll('.doc-section[id]');
        const navLinks = document.querySelectorAll('.sidebar a');
        
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
